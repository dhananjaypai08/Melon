import { NextRequest, NextResponse } from "next/server";
import crypto from "crypto";
import sharp from "sharp";

export async function POST(request) {
  try {
    const formData = await request.formData();
    const file = formData.get("image");

    if (!file) {
      return NextResponse.json(
        { success: false, error: "No image file provided" },
        { status: 400 }
      );
    }

    // Convert file to buffer
    const imageBuffer = Buffer.from(await file.arrayBuffer());

    // Extract metadata using Sharp (server-side)
    const metadata = await sharp(imageBuffer).metadata();

    if (!metadata.exif) {
      return NextResponse.json(
        { success: false, error: "No EXIF data found in image" },
        { status: 400 }
      );
    }

    // Parse EXIF to find UserComment
    let proof = null;
    try {
      proof = await extractProofFromSharpMetadata(imageBuffer);
    } catch (extractError) {
      return NextResponse.json(
        {
          success: false,
          error: `Failed to extract proof: ${extractError.message}`,
        },
        { status: 400 }
      );
    }

    if (!proof) {
      return NextResponse.json(
        { success: false, error: "No AI proof found in EXIF UserComment" },
        { status: 400 }
      );
    }

    // Verify this is an AI proof
    if (proof.proof_type !== "ai_generated") {
      return NextResponse.json(
        { success: false, error: "Not an AI-generated image proof" },
        { status: 400 }
      );
    }

    // Verify required fields
    if (
      !proof.image_hash ||
      !proof.signature ||
      !proof.public_key_b64 ||
      !proof.prompt ||
      !proof.ai_model
    ) {
      return NextResponse.json(
        {
          success: false,
          error: "Invalid AI proof format - missing required fields",
        },
        { status: 400 }
      );
    }

    // Check if this matches our server's public key
    const serverPublicKey = process.env.AI_PROOF_PUBLIC_KEY;
    if (!serverPublicKey) {
      return NextResponse.json(
        { success: false, error: "Server AI proof key not configured" },
        { status: 500 }
      );
    }

    if (proof.public_key_b64 !== serverPublicKey) {
      return NextResponse.json(
        {
          success: false,
          error: "Public key mismatch - not generated by this server",
        },
        { status: 400 }
      );
    }

    // Hash the image content (same way as generation)
    const recomputedHash = await hashImageContent(imageBuffer);
    const expectedHash = proof.image_hash;

    const hashMatch = recomputedHash === expectedHash;

    // Verify signature
    try {
      const publicKeyBuffer = Buffer.from(proof.public_key_b64, "base64");
      const publicKeyObj = crypto.createPublicKey({
        key: publicKeyBuffer,
        format: "der",
        type: "spki",
      });

      // Reconstruct payload for verification (exclude signature)
      const payload = { ...proof };
      delete payload.signature;

      // Canonicalize payload (same as generation)
      const canonicalMessage = JSON.stringify(
        payload,
        Object.keys(payload).sort()
      );
      const messageBuffer = Buffer.from(canonicalMessage, "utf-8");
      const signatureBuffer = Buffer.from(proof.signature, "base64");

      // Verify signature
      const signatureValid = crypto.verify(
        null,
        messageBuffer,
        publicKeyObj,
        signatureBuffer
      );

      return NextResponse.json({
        success: signatureValid,
        message: signatureValid
          ? "AI image authenticity verified successfully!"
          : "Signature verification failed",
        proofData: proof,
        verificationDetails: {
          signatureValid: signatureValid,
          hashMatch: hashMatch,
          hashNote: hashMatch
            ? "Image content unchanged"
            : "Hash mismatch due to format conversion (expected for AI images)",
          publicKeyMatch: true,
          generatedByThisServer: true,
          recomputedHash: recomputedHash,
          expectedHash: expectedHash,
        },
      });
    } catch (verifyError) {
      console.error("Signature verification error:", verifyError);
      return NextResponse.json(
        { success: false, error: "Signature verification failed" },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error("AI proof verification error:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

// Extract proof from Sharp metadata with enhanced debugging
async function extractProofFromSharpMetadata(imageBuffer) {
  console.log("üîç Starting Sharp metadata extraction...");

  // Use Sharp to get metadata
  const metadata = await sharp(imageBuffer).metadata();
  console.log("üìä Sharp metadata keys:", Object.keys(metadata));
  console.log("üìä Has EXIF:", !!metadata.exif);
  console.log("üìä EXIF buffer length:", metadata.exif?.length || 0);

  if (!metadata.exif) {
    throw new Error("No EXIF data found in Sharp metadata");
  }

  // Try multiple approaches to extract UserComment
  console.log("üîß Attempting multiple extraction methods...");

  // Method 1: Look for raw JSON string in EXIF buffer
  try {
    const exifString = metadata.exif.toString("utf8");
    console.log("üìù EXIF as string preview:", exifString.substring(0, 200));

    // Look for JSON patterns
    const jsonMatches = exifString.match(
      /\{[^}]*"proof_type"[^}]*"ai_generated"[^}]*\}/g
    );
    if (jsonMatches && jsonMatches.length > 0) {
      console.log("‚úÖ Found JSON match in EXIF string");
      const proof = JSON.parse(jsonMatches[0]);
      return proof;
    }
  } catch (e) {
    console.log("‚ùå Method 1 failed:", e.message);
  }

  // Method 2: Parse EXIF structure to find UserComment tag
  try {
    const view = new DataView(metadata.exif.buffer);
    console.log("üîç Parsing EXIF structure...");

    // Look for UserComment tag (0x9286) in the EXIF data
    for (let i = 0; i < view.byteLength - 20; i += 2) {
      try {
        const tag = view.getUint16(i, true); // little endian
        if (tag === 0x9286) {
          console.log(`‚úÖ Found UserComment tag at offset ${i}`);

          // Try to extract the data around this tag
          const type = view.getUint16(i + 2, true);
          const count = view.getUint32(i + 4, true);
          const valueOffset = view.getUint32(i + 8, true);

          console.log(
            `üìã Tag details - Type: ${type}, Count: ${count}, Offset: ${valueOffset}`
          );

          let dataOffset = count <= 4 ? i + 8 : valueOffset;

          if (dataOffset + count <= view.byteLength) {
            const userCommentData = new Uint8Array(
              metadata.exif,
              dataOffset,
              Math.min(count, 1000)
            );
            const userCommentString = new TextDecoder("utf-8", {
              fatal: false,
            }).decode(userCommentData);
            console.log(
              `üìù UserComment data preview: ${userCommentString.substring(
                0,
                100
              )}`
            );

            // Try to parse as JSON
            const cleanString = userCommentString.replace(/\0/g, "").trim();
            if (cleanString.includes("proof_type")) {
              console.log(
                "‚úÖ Found proof_type in UserComment, parsing JSON..."
              );
              const proof = JSON.parse(cleanString);
              return proof;
            }
          }
        }
      } catch (tagError) {
        // Continue searching
      }
    }

    // Also try big endian
    for (let i = 0; i < view.byteLength - 20; i += 2) {
      try {
        const tag = view.getUint16(i, false); // big endian
        if (tag === 0x9286) {
          console.log(`‚úÖ Found UserComment tag (big endian) at offset ${i}`);
          // Similar extraction logic...
        }
      } catch (tagError) {
        // Continue searching
      }
    }
  } catch (e) {
    console.log("‚ùå Method 2 failed:", e.message);
  }

  // Method 3: Brute force search for JSON pattern
  try {
    console.log("üîç Brute force searching for JSON pattern...");
    const exifBytes = new Uint8Array(metadata.exif);

    // Look for opening brace followed by common proof fields
    for (let i = 0; i < exifBytes.length - 50; i++) {
      if (exifBytes[i] === 0x7b) {
        // '{'
        // Found opening brace, try to extract JSON from here
        let jsonEnd = i;
        let braceCount = 0;

        for (let j = i; j < Math.min(i + 2000, exifBytes.length); j++) {
          if (exifBytes[j] === 0x7b) braceCount++;
          else if (exifBytes[j] === 0x7d) braceCount--;

          if (braceCount === 0) {
            jsonEnd = j;
            break;
          }
        }

        if (jsonEnd > i) {
          const jsonBytes = exifBytes.slice(i, jsonEnd + 1);
          const jsonString = new TextDecoder("utf-8", { fatal: false }).decode(
            jsonBytes
          );

          if (
            jsonString.includes("proof_type") &&
            jsonString.includes("ai_generated")
          ) {
            console.log("‚úÖ Found proof via brute force search");
            const proof = JSON.parse(jsonString);
            return proof;
          }
        }
      }
    }
  } catch (e) {
    console.log("‚ùå Method 3 failed:", e.message);
  }

  console.log("‚ùå All extraction methods failed");
  throw new Error(
    "UserComment not found in EXIF data after trying all methods"
  );
}

// Hash image content (same as generation)
async function hashImageContent(imageBuffer) {
  // Convert to consistent format and hash
  const jpegBuffer = await sharp(imageBuffer).jpeg({ quality: 95 }).toBuffer();

  return crypto.createHash("sha256").update(jpegBuffer).digest("hex");
}

export async function GET() {
  return NextResponse.json({
    configured: !!(
      process.env.AI_PROOF_PUBLIC_KEY && process.env.AI_PROOF_PRIVATE_KEY
    ),
    message: "AI Proof verification endpoint",
    publicKey: process.env.AI_PROOF_PUBLIC_KEY || null,
  });
}
